import sqlite3
import logging
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.preprocessing import StandardScaler
import numpy as np

# Database path
DB_PATH = "d:/hand/db/poker.db"

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Connect to the SQLite database
conn = sqlite3.connect(DB_PATH)
cursor = conn.cursor()

def reset_database():
    """Drop all tables in the database."""
    try:
        cursor.executescript("""
            DROP TABLE IF EXISTS Exploitability;
        """)
        conn.commit()
        logging.info("Database reset successfully.")
    except sqlite3.Error as e:
        logging.error(f"Error resetting database: {e}")

reset_database()

# Create the Exploitability table if it doesn't exist
cursor.execute('''
CREATE TABLE IF NOT EXISTS Exploitability (
    player_id INTEGER,
    hand_id INTEGER,
    position TEXT,
    vpip REAL,               -- % of hands voluntarily played
    pfr REAL,                -- % of hands raised preflop
    aggression_factor REAL,  -- Postflop aggression metric
    cbet_flop REAL,          
    cbet_turn REAL,          
    cbet_river REAL,         
    fold_to_cbet REAL,       
    showdown_win REAL,       
    three_bet_rate REAL,     -- Added 3-bet rate
    steal_attempt_rate REAL, -- Added steal attempt rate
    exploitability_score REAL,
    playstyle TEXT,          -- Added playstyle column
    opponent_tendency TEXT,  -- Added opponent_tendency column
    PRIMARY KEY (player_id, hand_id),
    FOREIGN KEY (hand_id) REFERENCES Hands (hand_id)
);
''')

# Query to calculate metrics with additional features
cursor.execute('''
SELECT 
    p.player_id,
    p.hand_id,
    p.position,
    ROUND(COUNT(CASE WHEN a.action_type IN ('Raise', 'Call', 'Bet') THEN 1 END) * 1.0 / COUNT(*), 4) AS vpip,
    ROUND(COUNT(CASE WHEN a.action_type = 'Raise' AND a.street = 'Preflop' THEN 1 END) * 1.0 / COUNT(*), 4) AS pfr,
    ROUND((COUNT(CASE WHEN a.action_type IN ('Raise', 'Bet') THEN 1 END) * 1.0) / 
    NULLIF(COUNT(CASE WHEN a.action_type = 'Call' THEN 1 END), 0), 4) AS aggression_factor,
    ROUND(COUNT(CASE WHEN a.action_type = 'Bet' AND a.street = 'Flop' THEN 1 END) * 1.0 / 
    NULLIF(COUNT(CASE WHEN a.street = 'Flop' THEN 1 END), 0), 4) AS cbet_flop,
    ROUND(COUNT(CASE WHEN a.action_type = 'Bet' AND a.street = 'Turn' THEN 1 END) * 1.0 / 
    NULLIF(COUNT(CASE WHEN a.street = 'Turn' THEN 1 END), 0), 4) AS cbet_turn,
    ROUND(COUNT(CASE WHEN a.action_type = 'Bet' AND a.street = 'River' THEN 1 END) * 1.0 / 
    NULLIF(COUNT(CASE WHEN a.street = 'River' THEN 1 END), 0), 4) AS cbet_river,
    ROUND(COUNT(CASE WHEN a.action_type = 'Fold' AND a.street IN ('Flop', 'Turn', 'River') THEN 1 END) * 1.0 / 
    NULLIF(COUNT(CASE WHEN a.street IN ('Flop', 'Turn', 'River') THEN 1 END), 0), 4) AS fold_to_cbet,
    ROUND(COUNT(CASE WHEN r.won_pot > 0 THEN 1 END) * 1.0 / 
    NULLIF(COUNT(CASE WHEN r.showdown = 1 THEN 1 END), 0), 4) AS showdown_win,
    ROUND(COUNT(CASE WHEN a.action_type = 'Raise' AND a.street = 'Preflop' AND a.position IN ('SB', 'BB') THEN 1 END) * 1.0 / 
    NULLIF(COUNT(CASE WHEN a.street = 'Preflop' AND a.position IN ('SB', 'BB') THEN 1 END), 0), 4) AS three_bet_rate,
    ROUND(COUNT(CASE WHEN a.action_type = 'Raise' AND a.street = 'Preflop' AND a.position IN ('BTN', 'CO') THEN 1 END) * 1.0 / 
    NULLIF(COUNT(CASE WHEN a.street = 'Preflop' AND a.position IN ('BTN', 'CO') THEN 1 END), 0), 4) AS steal_attempt_rate
FROM Players p
LEFT JOIN Actions a ON p.hand_id = a.hand_id AND p.player_id = a.player_id
LEFT JOIN Results r ON p.hand_id = r.hand_id AND p.player_id = r.player_id
GROUP BY p.player_id, p.hand_id;
''')
data = cursor.fetchall()

# Function to determine playstyle based on VPIP and PFR
def determine_playstyle(vpip, pfr):
    """Determine player's playstyle with more granular categories."""
    # Handle None values by converting them to 0
    vpip = 0 if vpip is None else vpip
    pfr = 0 if pfr is None else pfr
    
    if vpip < 0.15:
        if pfr > 0.12:
            return "TAG"  # Tight-Aggressive
        else:
            return "Nit"  # Tight-Passive
    elif vpip < 0.25:
        if pfr > 0.18:
            return "Semi-TAG"  # Semi-Tight Aggressive
        else:
            return "Weak-Tight"  # Weak-Tight
    elif vpip < 0.35:
        if pfr > 0.22:
            return "LAG"  # Loose-Aggressive
        else:
            return "Loose-Passive"
    else:
        if pfr > 0.25:
            return "Maniac"  # Extremely Loose-Aggressive
        else:
            return "Whale"  # Extremely Loose-Passive

# Function to determine opponent tendency based on aggression factor and fold-to-cbet
def determine_opponent_tendency(aggression_factor, fold_to_cbet):
    """Determine opponent tendency with more detailed categories."""
    # Handle None values by converting them to 0
    aggression_factor = 0 if aggression_factor is None else aggression_factor
    fold_to_cbet = 0 if fold_to_cbet is None else fold_to_cbet
    
    if fold_to_cbet > 0.75:
        if aggression_factor < 1.0:
            return "Ultra-Tight"
        elif aggression_factor < 1.5:
            return "Tight-Passive"
        else:
            return "Tight-Aggressive"
    elif fold_to_cbet > 0.55:
        if aggression_factor < 1.2:
            return "Semi-Tight"
        elif aggression_factor < 2.0:
            return "Balanced"
        else:
            return "Aggressive"
    else:
        if aggression_factor < 1.5:
            return "Loose-Passive"
        elif aggression_factor < 2.5:
            return "Loose-Aggressive"
        else:
            return "Maniac"

# Prepare data for training
X = []
y = []
for i, row in enumerate(data):
    # Replace None with 0 for all elements in the row
    data[i] = [0 if value is None else value for value in row]
    
    # Append features and target
    X.append(data[i][3:13])  # Features: vpip, pfr, aggression_factor, cbet_flop, cbet_turn, cbet_river, fold_to_cbet, showdown_win, three_bet_rate, steal_attempt_rate
    y.append(data[i][12])    # Target: exploitability_score (adjusted to row[12] since row has 13 elements)

# Convert to numpy arrays for scaling
X = np.array(X, dtype=np.float32)
y = np.array(y, dtype=np.float32).reshape(-1, 1)

# Scale features and target
scaler_X = StandardScaler()
X = scaler_X.fit_transform(X)

scaler_y = StandardScaler()
y = scaler_y.fit_transform(y)

# Convert to PyTorch tensors
X = torch.tensor(X, dtype=torch.float32)
y = torch.tensor(y, dtype=torch.float32)

# Define a more complex neural network with dropout
class AdvancedPokerNN(nn.Module):
    def __init__(self, input_size=10, hidden_size=128, num_layers=3):
        super(AdvancedPokerNN, self).__init__()
        self.layers = nn.ModuleList()
        self.layers.append(nn.Linear(input_size, hidden_size))
        self.layers.append(nn.ReLU())
        self.layers.append(nn.Dropout(0.3))
        
        for _ in range(num_layers - 1):
            self.layers.append(nn.Linear(hidden_size, hidden_size))
            self.layers.append(nn.ReLU())
            self.layers.append(nn.Dropout(0.3))
            
        self.output_layer = nn.Linear(hidden_size, 1)
        
    def forward(self, x):
        for layer in self.layers:
            x = layer(x)
        return self.output_layer(x)

def train_model(model, X, y, epochs=1000, patience=20):
    criterion = nn.MSELoss()
    optimizer = optim.AdamW(model.parameters(), lr=0.001, weight_decay=0.01)
    scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, 'min', patience=5, factor=0.5)
    
    best_loss = float('inf')
    patience_counter = 0
    
    for epoch in range(epochs):
        model.train()
        optimizer.zero_grad()
        outputs = model(X)
        loss = criterion(outputs, y)
        loss.backward()
        optimizer.step()
        scheduler.step(loss)
        
        # Early stopping
        if loss.item() < best_loss:
            best_loss = loss.item()
            patience_counter = 0
        else:
            patience_counter += 1
            if patience_counter >= patience:
                logging.info(f"Early stopping at epoch {epoch}")
                break
                
        if (epoch + 1) % 100 == 0:
            logging.info(f'Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}')

# Train the neural network
model = AdvancedPokerNN()
train_model(model, X, y)

def predict_batch(model, features_batch):
    """Make predictions for a batch of samples"""
    model.eval()  # Set model to evaluation mode
    with torch.no_grad():
        # Ensure features_batch is 2D (batch_size, num_features)
        if len(features_batch.shape) == 1:
            features_batch = features_batch.unsqueeze(0)
        # Convert to tensor if not already
        if not isinstance(features_batch, torch.Tensor):
            features_batch = torch.tensor(features_batch, dtype=torch.float32)
        # Make predictions
        predictions = model(features_batch)
        return predictions.squeeze().numpy()

# Prepare all features at once
all_features = np.array([
    [row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10], row[11], row[12]]
    for row in data
], dtype=np.float32)

# Scale all features
all_features = scaler_X.transform(all_features)

# Predict all scores at once
exploitability_scores = predict_batch(model, all_features)

# Insert data into the Exploitability table
for i, row in enumerate(data):
    player_id, hand_id, position = row[:3]
    
    # Get pre-calculated score
    exploitability_score = scaler_y.inverse_transform([[exploitability_scores[i]]])[0][0]
    exploitability_score = round(exploitability_score, 5)
    
    # Prepare all values for insertion
    values = (
        player_id,
        hand_id,
        position,
        *row[3:13],  # Unpack all metrics
        exploitability_score,
        determine_playstyle(row[3], row[4]),
        determine_opponent_tendency(row[5], row[9])
    )
    
    # Insert into database
    cursor.execute('''
    INSERT INTO Exploitability (
        player_id, hand_id, position, 
        vpip, pfr, aggression_factor, 
        cbet_flop, cbet_turn, cbet_river, 
        fold_to_cbet, showdown_win, 
        three_bet_rate, steal_attempt_rate, 
        exploitability_score, playstyle, opponent_tendency
    )
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', values)

# Commit the transaction
conn.commit()

# Query the Exploitability table to verify the data
cursor.execute('SELECT * FROM Exploitability LIMIT 10')
rows = cursor.fetchall()
for row in rows:
    print(row)

# Close the connection
conn.close()

def calculate_advanced_features(row):
    """Calculate additional poker-specific features"""
    features = {
        'vpip': row[3],
        'pfr': row[4],
        'aggression_factor': row[5],
        'cbet_flop': row[6],
        'cbet_turn': row[7],
        'cbet_river': row[8],
        'fold_to_cbet': row[9],
        'showdown_win': row[10],
        'three_bet_rate': row[11],
        'steal_attempt_rate': row[12],
        'vpip_pfr_ratio': row[3] / (row[4] + 1e-6),
        'aggression_index': (row[5] + row[6] + row[7] + row[8]) / 4,
        'fold_aggression_balance': row[9] * row[5],
        'position_factor': {'BTN': 1.0, 'CO': 0.8, 'MP': 0.6, 'EP': 0.4}.get(row[2], 0.5)
    }
    return list(features.values())

def advanced_player_profile(vpip, pfr, aggression_factor, fold_to_cbet):
    """Create a more detailed player profile"""
    profile = {
        'tightness': min(max((1 - vpip) * 2, 0), 1),
        'aggressiveness': min(max((pfr + aggression_factor) / 2, 0), 1),
        'predictability': min(max((1 - abs(vpip - pfr)) * fold_to_cbet, 0), 1),
        'style': determine_playstyle(vpip, pfr),
        'tendency': determine_opponent_tendency(aggression_factor, fold_to_cbet)
    }
    return profile

def main():
    # Initialize advanced model
    model = AdvancedPokerNN(input_size=13)  # 13 features now
    
    # Prepare enhanced features
    X_advanced = np.array([calculate_advanced_features(row) for row in data], dtype=np.float32)
    
    # Scale features
    scaler_X = StandardScaler()
    X_advanced = scaler_X.fit_transform(X_advanced)
    
    # Convert to tensors
    X_tensor = torch.tensor(X_advanced, dtype=torch.float32)
    y_tensor = torch.tensor(y, dtype=torch.float32)
    
    # Train model
    train_model(model, X_tensor, y_tensor)
    
    # Generate player profiles
    for row in data:
        profile = advanced_player_profile(row[3], row[4], row[5], row[9])
        # Store profile in database or use for decision making